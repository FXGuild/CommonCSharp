// MIT License
// 
// Copyright (c) 2016 FXGuild
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
// associated documentation files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.Serialization.Json;

using FXGuild.Common.Tracing.Model;

namespace FXGuild.Common.Tracing
{
   public static class TracerProvider
   {
      #region Compile-time constants

      public const string TRACE_MODEL_SUFFIX = ".TraceModel.json";

      #endregion

      #region Runtime constants

      private static readonly Dictionary<string, TraceModel> TRACE_MODELS;

      #endregion

      #region Constructors

      static TracerProvider()
      {
         TRACE_MODELS = new Dictionary<string, TraceModel>();

         // Load all trace model files in working directory
         foreach (string file in Directory.GetFiles(Directory.GetCurrentDirectory()))
         {
            // File must end with a special suffix generated by the TraceEnumGenerator tool
            if (!file.EndsWith(TRACE_MODEL_SUFFIX))
               continue;

            // Deserialize and save trace model
            using (var stream = File.OpenRead(file))
            {
               var serializer = new DataContractJsonSerializer(typeof(TraceModel));
               var model = serializer.ReadObject(stream) as TraceModel;
               string namespac = Path.GetFileName(file).Replace(TRACE_MODEL_SUFFIX, string.Empty);
               TRACE_MODELS.Add(namespac, model);
            }
         }
      }

      #endregion

      #region Static methods

      public static Tracer GetTracer<T>()
      {
         // Get the namespace of calling type
         string namespac = typeof(T).Namespace;

         // Search the cache for the corresponding trace model based on the namespace
         TraceModel traceModel = null;
         while (!string.IsNullOrEmpty(namespac) &&
                !TRACE_MODELS.TryGetValue(namespac, out traceModel)
                && (namespac.LastIndexOf('.') != -1))
            namespac = namespac.Remove(namespac.LastIndexOf('.'));

         if (traceModel == null)
            // TODO add exception info
            throw new Exception();

         return new Tracer(traceModel);
      }

      #endregion
   }
}
